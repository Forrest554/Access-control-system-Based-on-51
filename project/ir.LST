C51 COMPILER V9.01   IR                                                                    01/07/2019 16:31:19 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE IR
OBJECT MODULE PLACED IN ir.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ir.c COMPACT BROWSE DEBUG OBJECTEXTEND

line level    source

   1          
   2          #include "ir.h"
   3          
   4          /*
   5          **********************************************************************
   6          *                         本地全局变量
   7          **********************************************************************
   8          */
   9          sbit gIRIO = P3^2;                // 红外接收头的IO接在P3.2
  10          u8 gIrCode[5];                    // gIrCode的0-3用来放原始数据，4用来放经过校验确认无误的键值
  11          
  12          /*
  13          **********************************************************************
  14          *                         内部函数原型声明
  15          **********************************************************************
  16          */
  17          static void delay10us(void);
  18          static void delay100us(void);
  19          static void delay8ms(void);
  20          
  21          
  22          /*********************************************************************
  23          * 函 数 名       : IrInit
  24          * 函数功能               : 红外接收口初始化为中断下降沿触发模式
  25          * 参数列表       : 无
  26          * 函数输出       : 无
  27          *********************************************************************/
  28          void IrInit(void)
  29          {
  30   1              IT0 = 1;                // 下降沿触发
  31   1              EX0 = 1;                // 打开中断0允许
  32   1              EA = 1;                 // 打开总中断
  33   1      
  34   1              gIRIO = 1;                      // 初始化端口为高电平
  35   1      }
  36          
  37          
  38          /*********************************************************************
  39          * 函 数 名       : IrIsr
  40          * 函数功能               : 红外接在P3.2，对应外部中断0，也就是0号中断
  41          * 参数列表       : 无
  42          * 函数输出       : 无
  43          *********************************************************************/
  44          void IrIsr(void) interrupt 0
  45          {
  46   1              u8 i = 0;       // i用于循环接收4组数据（用户码、用户码反码、地址码、地址码反码）
  47   1              u8 j = 0;       // j用于接收1组数据中8个bit
  48   1              u16 cnt;        // cnt用于循环计数来设置等待超时时间
  49   1                                               
  50   1              delay8ms();                                             // 一共9ms，先延时消耗掉8ms
  51   1              if (gIRIO == 0)                                 // 如果不是干扰8ms后应该还是低电平
  52   1              {                       
  53   2                      cnt = 200;                                      // 200*10us=2ms, 超过说明接收到错误的信号
  54   2                      while ((gIRIO == 0) && (cnt > 0))       // 等待前面9ms的低电平过去              
  55   2                      {                       
C51 COMPILER V9.01   IR                                                                    01/07/2019 16:31:19 PAGE 2   

  56   3                              delay10us();                    // 每隔10us查一次，准确度很高
  57   3                              cnt--;
  58   3                      } 
  59   2      
  60   2                      if (gIRIO == 1)                         // 如果电平变高说明确实等到了高电平
  61   2                      {
  62   3                              cnt = 500;                              // 超时设置为500*10us=5ms
  63   3                              while ((gIRIO == 1) && (cnt > 0))                //等待4.5ms的起始高电平过去
  64   3                              {
  65   4                                      delay10us();
  66   4                                      cnt--;
  67   4                              }
  68   3                              for (i=0; i<4; i++)                             // 共有4组有效数据
  69   3                              {                       
  70   4                                      for (j=0; j<8; j++)                     // 循环接收一组数据
  71   4                                      {
  72   5                                              cnt = 60;               
  73   5                                              while ((gIRIO == 0) && (cnt > 0)) //消耗掉前面的560us低电平
  74   5                                              {
  75   6                                                      delay10us();
  76   6                                                      cnt--;
  77   6                                              }
  78   5      
  79   5                                              cnt = 0;
  80   5                                              while (gIRIO == 1)              // 计算高电平的时间长度。
  81   5                                              {
  82   6                                                      delay100us();           // 因为要计数所以用100us延时，这样
  83   6                                                      cnt++;                          // 其他语句对周期延时的影响比较小
  84   6                                                      if (cnt > 30)           // 计算出来的次数会比较准                
  85   6                                                      {
  86   7                                              //              UartSendByte(Time);             // 实测是0x1F也就是31
  87   7                                                              return;
  88   7                                                      }                                       // 排除长按按键带来的重复
  89   6                                              }
  90   5                                              gIrCode[i] >>= 1;               
  91   5                                              if (cnt >= 11)                  // 560us*2/100us = 11.2，所以是11
  92   5                                              {
  93   6                                                      gIrCode[i] |= 0x80;
  94   6                                              }                                                       
  95   5                                      }
  96   4                              }
  97   3                      }
  98   2                      if (gIrCode[2] == ~gIrCode[3])
  99   2                      {
 100   3                              gIrCode[4] = gIrCode[2];                // 更新键值数值以显示
 101   3                              return;
 102   3                      }
 103   2              }               
 104   1      }
 105          
 106          
 107          /*********************************************************************
 108          * 函 数 名       : delay10us
 109          * 函数功能               : 单片机小精灵V1.3生成的延时10us的精确延时函数
 110          * 参数列表       : 无
 111          * 函数输出       : 无
 112          *********************************************************************/
 113          static void delay10us(void)   //误差 0us
 114          {
 115   1          unsigned char a,b;
 116   1          for(b=1;b>0;b--)
 117   1              for(a=2;a>0;a--);
C51 COMPILER V9.01   IR                                                                    01/07/2019 16:31:19 PAGE 3   

 118   1      }
 119          
 120          
 121          /*********************************************************************
 122          * 函 数 名       : delay100us
 123          * 函数功能               : 单片机小精灵V1.3生成的延时100us的精确延时函数
 124          * 参数列表       : 无
 125          * 函数输出       : 无
 126          *********************************************************************/
 127          static void delay100us(void)   //误差 0us
 128          {
 129   1          unsigned char a,b;
 130   1          for(b=19;b>0;b--)
 131   1              for(a=1;a>0;a--);
 132   1      }
 133          
 134          
 135          /*********************************************************************
 136          * 函 数 名       : delay8ms
 137          * 函数功能               : 单片机小精灵V1.3生成的延时8ms的精确延时函数
 138          * 参数列表       : 无
 139          * 函数输出       : 无
 140          *********************************************************************/
 141          static void delay8ms(void)   //误差 0us
 142          {
 143   1          unsigned char a,b;
 144   1          for(b=205;b>0;b--)
 145   1              for(a=18;a>0;a--);
 146   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    350    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      5       4
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
