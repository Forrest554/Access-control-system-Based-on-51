
#include "ir.h"

/*
**********************************************************************
*                         本地全局变量
**********************************************************************
*/
sbit gIRIO = P3^2;		  // 红外接收头的IO接在P3.2
u8 gIrCode[5];  		  // gIrCode的0-3用来放原始数据，4用来放经过校验确认无误的键值

/*
**********************************************************************
*                         内部函数原型声明
**********************************************************************
*/
static void delay10us(void);
static void delay100us(void);
static void delay8ms(void);


/*********************************************************************
* 函 数 名       : IrInit
* 函数功能		 : 红外接收口初始化为中断下降沿触发模式
* 参数列表       : 无
* 函数输出    	 : 无
*********************************************************************/
void IrInit(void)
{
	IT0 = 1;		// 下降沿触发
	EX0 = 1;		// 打开中断0允许
	EA = 1;			// 打开总中断

	gIRIO = 1;			// 初始化端口为高电平
}


/*********************************************************************
* 函 数 名       : IrIsr
* 函数功能		 : 红外接在P3.2，对应外部中断0，也就是0号中断
* 参数列表       : 无
* 函数输出    	 : 无
*********************************************************************/
void IrIsr(void) interrupt 0
{
	u8 i = 0;	// i用于循环接收4组数据（用户码、用户码反码、地址码、地址码反码）
	u8 j = 0;	// j用于接收1组数据中8个bit
	u16 cnt;	// cnt用于循环计数来设置等待超时时间
					 
	delay8ms();						// 一共9ms，先延时消耗掉8ms
	if (gIRIO == 0)					// 如果不是干扰8ms后应该还是低电平
	{	 		
		cnt = 200;					// 200*10us=2ms, 超过说明接收到错误的信号
		while ((gIRIO == 0) && (cnt > 0))	// 等待前面9ms的低电平过去  		
		{			
			delay10us();			// 每隔10us查一次，准确度很高
			cnt--;
		} 

		if (gIRIO == 1)				// 如果电平变高说明确实等到了高电平
		{
			cnt = 500;				// 超时设置为500*10us=5ms
			while ((gIRIO == 1) && (cnt > 0))		 //等待4.5ms的起始高电平过去
			{
				delay10us();
				cnt--;
			}
			for (i=0; i<4; i++)				// 共有4组有效数据
			{			
				for (j=0; j<8; j++)			// 循环接收一组数据
				{
					cnt = 60;		
					while ((gIRIO == 0) && (cnt > 0)) //消耗掉前面的560us低电平
					{
						delay10us();
						cnt--;
					}

					cnt = 0;
					while (gIRIO == 1)	 	// 计算高电平的时间长度。
					{
						delay100us();		// 因为要计数所以用100us延时，这样
						cnt++;			  	// 其他语句对周期延时的影响比较小
						if (cnt > 30)		// 计算出来的次数会比较准		 
						{
					//		UartSendByte(Time);		// 实测是0x1F也就是31
							return;
						}					// 排除长按按键带来的重复
					}
					gIrCode[i] >>= 1;	 	
					if (cnt >= 11)			// 560us*2/100us = 11.2，所以是11
					{
						gIrCode[i] |= 0x80;
					}							
				}
			}
		}
		if (gIrCode[2] == ~gIrCode[3])
		{
			gIrCode[4] = gIrCode[2];  		// 更新键值数值以显示
			return;
		}
	}		
}


/*********************************************************************
* 函 数 名       : delay10us
* 函数功能		 : 单片机小精灵V1.3生成的延时10us的精确延时函数
* 参数列表       : 无
* 函数输出    	 : 无
*********************************************************************/
static void delay10us(void)   //误差 0us
{
    unsigned char a,b;
    for(b=1;b>0;b--)
        for(a=2;a>0;a--);
}


/*********************************************************************
* 函 数 名       : delay100us
* 函数功能		 : 单片机小精灵V1.3生成的延时100us的精确延时函数
* 参数列表       : 无
* 函数输出    	 : 无
*********************************************************************/
static void delay100us(void)   //误差 0us
{
    unsigned char a,b;
    for(b=19;b>0;b--)
        for(a=1;a>0;a--);
}


/*********************************************************************
* 函 数 名       : delay8ms
* 函数功能		 : 单片机小精灵V1.3生成的延时8ms的精确延时函数
* 参数列表       : 无
* 函数输出    	 : 无
*********************************************************************/
static void delay8ms(void)   //误差 0us
{
    unsigned char a,b;
    for(b=205;b>0;b--)
        for(a=18;a>0;a--);
}